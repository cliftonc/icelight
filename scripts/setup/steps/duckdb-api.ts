/**
 * DuckDB API worker deployment step
 */

import { existsSync, readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import type { DeployedUrls } from '../core/types.js';
import {
  getWorkersPath,
  getScriptsPath,
  parseJsonc,
  runCommandAsync,
  runCommandWithOutputAsync,
  extractWorkerUrl,
  checkWorkerDeployedAsync,
  setSecretAsync,
  constructWorkerUrl,
} from '../core/wrangler.js';
import { promptRedeploy } from '../core/prompts.js';

/**
 * Get worker name based on project name
 */
export function getDuckDbApiWorkerName(projectName: string): string {
  return `${projectName}-duckdb-api`;
}

/**
 * Get paths for duckdb-api worker
 */
function getPaths() {
  const workerPath = join(getWorkersPath(), 'duckdb-api');
  return {
    basePath: join(workerPath, 'wrangler.jsonc'),
    localPath: join(workerPath, 'wrangler.local.jsonc'),
    extensionsScript: join(getScriptsPath(), 'download-extensions.sh'),
  };
}

/**
 * Create wrangler.local.jsonc for duckdb-api worker
 */
export function createDuckDbApiLocalConfig(projectName: string, warehouseName: string, catalogUri: string): boolean {
  const { basePath, localPath } = getPaths();

  if (!existsSync(basePath)) {
    return false;
  }

  try {
    const baseContent = readFileSync(basePath, 'utf-8');
    const config = parseJsonc(baseContent) as Record<string, unknown>;

    // Set worker name based on project
    config.name = getDuckDbApiWorkerName(projectName);

    // Add R2 catalog configuration to vars
    const vars = (config.vars as Record<string, unknown>) || {};
    vars.R2_CATALOG = warehouseName;
    vars.R2_ENDPOINT = catalogUri;
    config.vars = vars;

    // Add observability
    config.observability = { enabled: true };

    // Write local config with comment header
    const localContent = `// Local wrangler config - DO NOT COMMIT
// Generated by: pnpm launch
// Contains environment-specific values for your Cloudflare account
${JSON.stringify(config, null, 2)}
`;

    writeFileSync(localPath, localContent);
    return true;
  } catch {
    return false;
  }
}

/**
 * Download DuckDB extensions (async for spinner animation)
 */
export async function downloadExtensions(): Promise<boolean> {
  const { extensionsScript } = getPaths();
  if (!existsSync(extensionsScript)) {
    return false;
  }
  return runCommandAsync(`bash "${extensionsScript}"`);
}

/**
 * Deploy duckdb-api worker (async for spinner animation)
 * Note: Container deploys can take a while and may return non-zero even on success
 */
export async function deployDuckDbApi(): Promise<{ success: boolean; url?: string; error?: string }> {
  const { localPath } = getPaths();
  const result = await runCommandWithOutputAsync(`wrangler deploy --config "${localPath}" --containers-rollout=immediate`);

  const output = result.output;
  const url = extractWorkerUrl(output);

  // Check for success indicators in output
  // Wrangler may return non-zero during container builds even when successful
  const successIndicators = [
    'Uploaded ',
    'Published ',
    'Current Version ID:',
    'workers.dev',
  ];
  const hasSuccessIndicator = successIndicators.some(indicator => output.includes(indicator));

  // Check for definite failure indicators
  const failureIndicators = [
    'Error:',
    'error:',
    'Failed to',
    'could not',
  ];
  const hasFailureIndicator = failureIndicators.some(indicator => output.toLowerCase().includes(indicator.toLowerCase()));

  // Success if: explicit success OR (has success indicator AND no failure indicator)
  if (result.success || (hasSuccessIndicator && !hasFailureIndicator)) {
    return { success: true, url: url || undefined };
  }

  // If we found a URL, it probably worked even if there were errors
  if (url) {
    return { success: true, url };
  }

  return { success: false, error: output };
}

/**
 * Set DuckDB API secrets (async for spinner animation)
 */
export async function setDuckDbApiSecrets(apiToken: string): Promise<boolean> {
  const { localPath } = getPaths();
  return setSecretAsync('R2_TOKEN', apiToken, localPath);
}

/**
 * Check if duckdb-api worker is deployed (async for spinner animation)
 */
export async function checkDuckDbApiDeployedAsync(projectName: string, subdomain?: string) {
  const workerName = getDuckDbApiWorkerName(projectName);
  return checkWorkerDeployedAsync(workerName, subdomain);
}

/**
 * Full duckdb-api setup flow
 */
export async function setupDuckDbApi(
  projectName: string,
  warehouseName: string,
  catalogUri: string,
  apiToken: string,
  deployedUrls: DeployedUrls,
  skipPrompts = false,
  subdomain?: string
): Promise<{ success: boolean; url?: string }> {
  // Create local config
  if (!createDuckDbApiLocalConfig(projectName, warehouseName, catalogUri)) {
    return { success: false };
  }

  // Check if already deployed
  const status = await checkDuckDbApiDeployedAsync(projectName, subdomain);
  let shouldDeploy = true;

  if (status.deployed && !skipPrompts) {
    if (status.url) {
      deployedUrls.duckdb = status.url;
    }
    shouldDeploy = await promptRedeploy('DuckDB API');
  }

  if (shouldDeploy) {
    // Download extensions first
    await downloadExtensions();

    // Deploy worker
    const workerName = getDuckDbApiWorkerName(projectName);
    const result = await deployDuckDbApi();
    if (result.success) {
      // Use extracted URL or construct it from worker name and subdomain
      const url = result.url || constructWorkerUrl(workerName, subdomain);
      if (url) {
        deployedUrls.duckdb = url;
      }
      // Set secrets after successful deploy
      if (apiToken) {
        await setDuckDbApiSecrets(apiToken);
      }
      return { success: true, url: url || undefined };
    }
    return result;
  }

  return { success: true, url: status.url || undefined };
}

/**
 * Get the config path for duckdb-api worker
 */
export function getDuckDbApiConfigPath(): string {
  return getPaths().localPath;
}
