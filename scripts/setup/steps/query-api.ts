/**
 * Query API worker deployment step
 */

import { existsSync, readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import type { DeployedUrls, LocalConfigOptions } from '../core/types.js';
import {
  getWorkersPath,
  parseJsonc,
  runCommandAsync,
  runCommandWithOutputAsync,
  extractWorkerUrl,
  checkWorkerDeployedAsync,
  setSecretAsync,
  constructWorkerUrl,
} from '../core/wrangler.js';
import { promptRedeploy } from '../core/prompts.js';

/**
 * Get worker name based on project name
 */
export function getQueryApiWorkerName(projectName: string): string {
  return `${projectName}-query-api`;
}

/**
 * Get paths for query-api worker
 */
function getPaths() {
  const workerPath = join(getWorkersPath(), 'query-api');
  return {
    basePath: join(workerPath, 'wrangler.jsonc'),
    localPath: join(workerPath, 'wrangler.local.jsonc'),
    migrationsPath: join(workerPath, 'migrations'),
  };
}

/**
 * Create wrangler.local.jsonc for query-api worker
 */
export function createQueryApiLocalConfig(
  projectName: string,
  warehouseName: string,
  options: LocalConfigOptions = {}
): boolean {
  const { basePath, localPath } = getPaths();

  if (!existsSync(basePath)) {
    return false;
  }

  try {
    const baseContent = readFileSync(basePath, 'utf-8');
    const config = parseJsonc(baseContent) as Record<string, unknown>;

    // Set worker name based on project
    config.name = getQueryApiWorkerName(projectName);

    // Add or update WAREHOUSE_NAME in vars
    const vars = (config.vars as Record<string, unknown>) || {};
    vars.WAREHOUSE_NAME = warehouseName;
    config.vars = vars;

    // Add KV namespace binding if IDs are provided
    if (options.kvCacheId) {
      config.kv_namespaces = [
        {
          binding: 'CACHE',
          id: options.kvCacheId,
          ...(options.kvCachePreviewId ? { preview_id: options.kvCachePreviewId } : {}),
        },
      ];
    }

    // Add D1 database binding if ID is provided
    if (options.d1DatabaseId && options.d1DatabaseName) {
      config.d1_databases = [
        {
          binding: 'DB',
          database_name: options.d1DatabaseName,
          database_id: options.d1DatabaseId,
        },
      ];
    }

    // Write local config with comment header
    const localContent = `// Local wrangler config - DO NOT COMMIT
// Generated by: pnpm launch
// Contains environment-specific values for your Cloudflare account
${JSON.stringify(config, null, 2)}
`;

    writeFileSync(localPath, localContent);
    return true;
  } catch {
    return false;
  }
}

/**
 * Run D1 migrations (async for spinner animation)
 */
export async function runMigrations(databaseName: string): Promise<{ success: boolean; applied: string[] }> {
  const { migrationsPath } = getPaths();
  const applied: string[] = [];

  if (!existsSync(migrationsPath)) {
    return { success: false, applied };
  }

  const migrationFiles = ['0000_create_dashboards.sql', '0001_seed_default.sql'];

  for (const file of migrationFiles) {
    const migrationPath = join(migrationsPath, file);
    if (existsSync(migrationPath)) {
      const success = await runCommandAsync(
        `wrangler d1 execute "${databaseName}" --file="${migrationPath}" --remote`
      );
      if (success) {
        applied.push(file);
      }
    }
  }

  return { success: applied.length > 0, applied };
}

/**
 * Deploy query-api worker (async for spinner animation)
 */
export async function deployQueryApi(): Promise<{ success: boolean; url?: string; error?: string }> {
  const { localPath } = getPaths();
  const result = await runCommandWithOutputAsync(`wrangler deploy --config "${localPath}"`);

  const output = result.output;
  const url = extractWorkerUrl(output);

  // Check for success indicators
  const successIndicators = ['Uploaded ', 'Published ', 'Current Version ID:', 'workers.dev'];
  const hasSuccessIndicator = successIndicators.some(indicator => output.includes(indicator));

  if (result.success || hasSuccessIndicator || url) {
    return { success: true, url: url || undefined };
  }
  return { success: false, error: output };
}

/**
 * Set Query API secrets (async for spinner animation)
 */
export async function setQueryApiSecrets(accountId: string, apiToken: string): Promise<boolean> {
  const { localPath } = getPaths();
  const accountResult = await setSecretAsync('CF_ACCOUNT_ID', accountId, localPath);
  const tokenResult = await setSecretAsync('CF_API_TOKEN', apiToken, localPath);
  return accountResult && tokenResult;
}

/**
 * Check if query-api worker is deployed (async for spinner animation)
 */
export async function checkQueryApiDeployedAsync(projectName: string, subdomain?: string) {
  const workerName = getQueryApiWorkerName(projectName);
  return checkWorkerDeployedAsync(workerName, subdomain);
}

/**
 * Full query-api setup flow
 */
export async function setupQueryApi(
  projectName: string,
  warehouseName: string,
  options: LocalConfigOptions,
  databaseName: string,
  accountId: string,
  apiToken: string,
  deployedUrls: DeployedUrls,
  skipPrompts = false,
  subdomain?: string
): Promise<{ success: boolean; url?: string }> {
  // Create local config
  if (!createQueryApiLocalConfig(projectName, warehouseName, options)) {
    return { success: false };
  }

  // Check if already deployed
  const status = await checkQueryApiDeployedAsync(projectName, subdomain);
  let shouldDeploy = true;

  if (status.deployed && !skipPrompts) {
    if (status.url) {
      deployedUrls.query = status.url;
    }
    shouldDeploy = await promptRedeploy('Query API');
  }

  if (shouldDeploy) {
    // Run migrations if D1 database exists (only when deploying)
    if (options.d1DatabaseId) {
      await runMigrations(databaseName);
    }

    const workerName = getQueryApiWorkerName(projectName);
    const result = await deployQueryApi();
    if (result.success) {
      // Use extracted URL or construct it from worker name and subdomain
      const url = result.url || constructWorkerUrl(workerName, subdomain);
      if (url) {
        deployedUrls.query = url;
      }
      // Set secrets after successful deploy
      await setQueryApiSecrets(accountId, apiToken);
      return { success: true, url: url || undefined };
    }
    return result;
  }

  return { success: true, url: status.url || undefined };
}

/**
 * Get the config path for query-api worker
 */
export function getQueryApiConfigPath(): string {
  return getPaths().localPath;
}
